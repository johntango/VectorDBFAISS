So let's see if we can solve what's called the Tower of Hanoi problem. This is a famous problem where monks were asked to move all the disks from one tower to another tower using a third tower as a staging point. But they could only ever move the top disk of any stack, and they could only move one disk at a time. And any disk that was moved must be moved to a tower to sit on top of a larger disk. So you can never have a larger disk sitting on top of a smaller one. So the goal is to get from this configuration to this configuration, but to do it moving disks one at a time. So let's see if we can program this. So let's have some notation first. Suppose I've got a function that can move n disks from A to C using B as the intermediate peg, the spare peg. So that's what this means. Now, let's suppose if we know how to do it for n disks, then we certainly know how to do it for n minus one disks. So we can do move n minus one from A to B, move with C, for example, as the intermediate. So we can take n minus one of these and move them to peg B. Now, what use is that to us? Well, if we can do that with n minus one, then we're going to get to this state. We'll move n minus one to B. Now, can you see how we can solve it? Now we can move this one to C. And if we know how to move n minus one, we can move the rest here onto C. So let's see that. And so now I've moved disk, the largest disk, n from A to C. I've moved n minus one of them from A to B. Now, what do I need to do to finish this? Well, I need to move n minus one from B to C. OK, so this is going to be our algorithm. Let's just take a look at what happens for, say, three disks. So let's suppose we're applying our algorithm to three disks. So we want to move three of them from A to C. And we know we can break that down into moving two of them from A to B. Then we move disk three from A to C and move two of the disks back then from B to C. Now, notice we're calling move with the arguments in different permutations. So we have to be a little bit careful in our logic as we think through it here. But actually, when we come to programming, it's going to automatically take care of it, which we'll see. So now let's have a look at these move two's. So here we have a move two and let's break it down. We want to move two of the disks from A to B. Then we move the big disk, third disk from A to C directly. And then we move the two from here back. So we want to go from A to B with two of them. So that means we move one of them from A to C. So the top one, we're taking two of them from here now, and we want to move one from A to C. Then we move disk two from A to B. There it is at the bottom. And now we move one from C to B. And now we move disk three over and then repeat this with moving one from B to A. So we move the top one back to A, move disk two B to C, and then move from A to C. OK. So that's going to be what we need to do. Let's take a little look what happens when we hit one here. We're just doing this one, moving two from A to B using C. Now we call move with one A to C. Now we don't want to call move zero, so we put an if statement in. If n equals one, just move that disk A to C. Now we move disk two from A to B, disk two from A to B. And then again, we want to call move this disk back from C to B. But we want to do this check if. So we need an if statement in there to stop it when it gets to one. So that's the trick. So let's go and take a look at our code. So here's the code. Here's our function, move disks. And we move n disks from whatever the from is. So we're going to set that up as down here, here, we're actually firing move disks. So the from is A, and the two is C, and the spare is B, we're going to call. So from A to C with B as the spare. So we put the if statement in. If n happens to be equal to one, then we directly move the disk. Otherwise, we call move disks n minus one, and we move from whatever from is to the spare, and using the other one, which is two, as the spare. Okay, so this is how the letters get changed around. And now we know we're moving from the spare to the final destination and using from. So, and in between, we just move that last biggest disk across whatever it is. So that's the algorithm. Notice that we're calling ourselves, this is a function, and this is called recursion. So we'll see if we step through this, that we're calling the same function again. And so we have to hold a pointer to where we got to. If we got to this point here, then when we return from this function, we need to step onto here. However, if we call the function from this point, we need to make sure we step on, and that'll be to the end. Okay, so that's the code. And the unbelievable thing is that that will work for any number of disks n. Now, the monks found out that if n is large like 64, and that was the task for the monks, they needed to move 64 disks, they found that it would be longer than the life of the whole universe to date. That if they could move one disk a second even, that it would just take forever. And so this is the trick, if you like, of the Tower of Hanoi, but we can program it just like this. Okay, let's see it run. So I've set it up to move two disks. Let's see if it runs. To run it, I'm using something called node, which you've loaded on your machine, but we haven't dealt with yet. So don't worry about that. And Hanoi.js. That was the code I wrote. So for two disks, we just move the top disk from A to B, the bottom disk from A to C, and then the little disk from B to C. And that will solve it. Let's run it now with three disks. Okay, so now I've set it up with three disks. Let's run it again and see what the result is. So you see this time we have to do a lot more moves. So take a look. Check this out. It does give the right solution. And let's try something with four disks. So here we are with four disks now. I'm going to clear that and run with four disks. So how many steps? Counting. There are actually, if I count these, there are 15 moves. And before, we found there were seven moves actually. And before there were three. So three, seven, fifteen. See if you can spot the pattern and predict how many moves five disks will take. There is a pattern there. Okay, so that's recursion and we'll have an exercise on this. Bye for now.
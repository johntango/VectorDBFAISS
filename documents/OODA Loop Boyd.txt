Hi, it's John Williams here at MIT and today I want to talk to you about a fighter pilot that changed the way that we designed software. So the fighter pilot's name was John Boyd and he flew jet planes during the Korean War and came up with a concept called the OODA loop which we use in agile software development and I want to explain the connection. So during the Korean War there were two kinds of fighter planes. The US was flying the F-86 and the North Koreans were flying a Russian MiG, MiG-15. Now the F-86 had a 9 to 1 kill ratio over the MiGs. They shot down 9 times as many MiGs as MiGs shot down US F-86s. But the surprising thing was that the MiG was a superior plane. The MiG could out-accelerate, its top speed was greater, it could out-climb, it could out-turn the F-86 and yet the F-86 had this 9 to 1 kill ratio. And John Boyd began to explore why and he looked at the layout of the cockpit and one major difference was that the F-86 had hydraulic controls and the MiG had mechanical controls. The MiG pilots needed to lift weights to be strong enough to fly the MiG. And what John Boyd concluded was that the F-86 pilots could go through their decision loop when they were conducting a dogfight they had to maneuver quickly. And John Boyd concluded that they could go through their decision loop much faster than the MiG pilots. And he came up with the concept of the OODA loop, observe, orient, decide and act. And he believed that this is what a pilot did during a dogfight. They had to observe where the opposition was, they had to orient themselves with respect to the opposition, decide what they wanted to do with their plane and act. And he believed if you could go around this faster than your opponent you would win. He called this getting inside your opponent's OODA loop. Now he believed this applied to a lot more circumstances than just flying airplanes. In fact he believed that this is what you needed to do in any situation where there was a high degree of uncertainty. And this is the actual OODA loop that he came up with, but it has the same four major parts to it, observe, orient, decide and act. Now how does this apply to software? Well traditionally we started with a waterfall method of software development where this was a very slow process of coming up with conceiving the product, initiating the project, analyzing, coming up with specs, designing it, constructing the product, testing, deployment. And this was a sequential process. There were some loops in this obviously, you needed to do rework. However for example Microsoft used this with Visual Studio and it would take two years to go through this loop. Now today we believe that the agile method offers some advantages, especially when we're dealing with projects where we have little experience before. So the agile manifesto is that essentially individuals and interactions take priority over processes and tools. We want to have working software rather than comprehensive documentation. We prefer to collaborate with the customer rather than having strict contract negotiations. And we need to be able to respond to change rather than following a plan. And this is very much like the OODA loop that we believe that you need to go through this loop quickly to get some experience, to understand what the actual problem really is. And we'll come back to talking about large scale complex systems and understanding exactly what kind of system we're dealing with. Is it a fairly simple system or is it a complex system? Is it a complex adaptive system? Is it a chaotic system for example? Now let's take a look. The waterfall strengths are that it has meticulous record keeping so when we have new people coming on the team they can read the documentation of where we are and it's there. The client knows exactly what to expect. They have an idea of the size, cost and timeline for the project up front. That's what they contract for. So the weaknesses are once we've taken one step, for example deciding what the product should do, we can't go back to a previous step and make changes. It relies heavily on initial requirements and if they're faulty the project is doomed. The whole product needs to be tested only at the end. We can only test it when we deploy it basically for the first time or rather deploy it on our own machines. And additionally the temptation to delay thorough testing is often high because we're going for short term wins to stay on schedule and it doesn't take into account the clients evolving needs. Now there are times when we can use waterfall. When there's a clear picture of what the final product should be, perhaps you designed a similar one before and when the clients won't have the ability to change the scope once the project has begun. Often this is the case with government projects that they can't change what they want because the contract has already been written. And also when definition of speed is the key to success, for example in the military often we need high precision rather than speed to deployment. Now the agile strengths allows for change. It actually, we have small parts where we deploy code called sprints and we reevaluate the priorities and this allows client to give their feedback and ultimately to get the product that they really want. And we test at the end of every sprint to ensure that the bugs are caught, taken care of as soon as possible so they won't be there at the end. And because the products are tested thoroughly with agile, the product could be launched at the end of any cycle and thus it's more likely to reach its launch date and be deployed on time. Now the weaknesses are that if your project manager doesn't have a great deal of experience, it can become a series of code sprints and we don't really have an architect there that keeps everyone in sync. And since the project doesn't have a definitive plan, the product could be grossly different to what was initially intended. But we typically use agile when we don't understand the problem at the beginning, that we need to get some experience, we need to find out what the bottlenecks are likely to be. And also when the client doesn't actually know what the final product should look like, that perhaps there's a new development in technology which they're not familiar with yet and which could be deployed to their advantage. And we can do it when we've got skilled developers that are adaptable and can think independently. And also when the product's intended for an industry, rapidly changing standards. Now how do we tell when we should deploy one method or another? We need to look at the system we're trying to build and understand some of its properties. I'm just going to quickly sketch out. So we talk about systems and systems thinking and we could ask the question, are there limits to systems thinking, but there's a very interesting framework called the Kenevin framework developed by a guy called David Stone and he believes there are kind of four categories of system. Down on the bottom right we have simple systems and in that case we can sense the system, categorize it and respond and we can employ best practices. Now when we have a complicated system, this is the top right, we need to sense, analyze them and respond and in this case there may be a number of solutions and we need to employ good practice. We don't know what the best practice may be. Now in the top left we have complex systems or sometimes complex adaptive systems and in this case we need to probe the system, we need to kind of sense how it responds and we need to respond to that because it has emergent behavior and in the bottom left we have chaotic behavior in which case we have to try and stabilize it fast. We have to act immediately, sense and then respond because we're dealing with novel situations. Now Snowden believes that the kinds of systems that we're designing today are not the same as we were designing 40 years ago and yet our companies are structured very much the same way. Now he believes that 40 years ago a lot of the systems were simple systems. A lot of the systems were simple systems and were pretty much along this black line that I'm highlighting here but today the systems are complex systems, complex adaptive systems even and that we're treating them as if they were simple or just complicated systems and this can lead to disaster. I highly encourage you to watch his videos. Here's one video on YouTube and this gives you an idea of what we're dealing with in software today and why perhaps Agile needs to be deployed or depending if it's a simpler system, maybe Waterfall but we need to look at the system and categorize it. So I hope you've enjoyed this short talk on the difference between Agile and Waterfall and why a fighter pilot named John Boyd changed the art of warfare and of software development. So I hope you enjoyed this. Bye bye. Bye. Bye.
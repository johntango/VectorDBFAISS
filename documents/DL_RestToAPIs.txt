We've been talking about legacy systems and the internet, and the web really gave rise to APIs. So here I'm talking about the World Wide Web. And Sir Tim Berners-Lee inventing HTTP and web pages, HTML and CSS. And this really gave rise, when the browser was invented, to the concept of a web server. And that web server was often sitting on port 80. So what I mean by that is we've got the IP address which takes us to a machine, but then the port number specifies some application running on that machine. Some piece of software. And in this case we're talking about a web server. Now the request response means that from our browser we send a request message and we'll get a response back. And that response could include data. So we started with a static web page model where we were actually serving up a web page. Then these began to be dynamic. So we may have multiple applications running on a single server. Here I'm showing the web server on port 80, the mail server on 3039, and the camera program on 8080. And here we can actually specify a function on the camera program. And I'm calling it getPhoto. And what that means is we can now address not only an application, but a particular function that's running on that application. So now we've got great control with this message that's being sent to fire a function on a remote machine. And here we're firing getPhoto on the camera program. So this is where the idea of APIs came from. That now we can specify if you want to talk to my program, the camera program, we can have different routes on it. So here /takePhoto is one route, so that'll fire one function. panLeft will fire another function and control the camera, say. And wakeUp will fire another function. And sleep will fire yet another one. And so now we've got the concept of APIs. So this is where the idea of rest routes came from. And here I'm showing we're making a request to a single application. And it's running on port 1337. And we can hit a route. Here I'm showing restaurants, so we can fire a function to get all the data about restaurants back. And here is another function, dishes, which will tell us about what are the dishes that each restaurant serves. And this is important because often when we're making queries for data, the data doesn't lie in just one place. That we may need to hit either different parts of the same program or actually different machines even. And this is where GraphQL comes in, in that it makes it simpler for us to do this. So here I'm showing we're hitting GraphQL that's running on one server. And yet we may have other servers that have the various pieces of information that we need to compose. So we might get the restaurants and the dishes. And we might get their opening times or reviews from yet another server. And these servers may be running across the web. So with federated query and GraphQL, now we can hit one server with the query. And it will take care of hitting these other URLs across the internet to get the data. And then it will compose it and return to us what we need. So we have APIs. And now we have added onto APIs GraphQL and federated query that allow us to simplify, if you like, this process of making queries to multiple machines to compose the data that we need. Okay, so that's how a legacy system has evolved into a sophisticated piece now of our data pipelines. Bye for now.